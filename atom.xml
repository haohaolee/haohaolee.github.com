<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[haohaolee's blog]]></title>
  <link href="http://blog.haohaolee.com/atom.xml" rel="self"/>
  <link href="http://blog.haohaolee.com/"/>
  <updated>2012-11-06T23:21:53+08:00</updated>
  <id>http://blog.haohaolee.com/</id>
  <author>
    <name><![CDATA[haohaolee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Microsoft Application Compatibility Toolkit 管教不规矩的程序]]></title>
    <link href="http://blog.haohaolee.com/blog/2012/03/25/use-microsoft-application-compatibility-toolkit-to-limit-unruly-apps/"/>
    <updated>2012-03-25T10:45:00+08:00</updated>
    <id>http://blog.haohaolee.com/blog/2012/03/25/use-microsoft-application-compatibility-toolkit-to-limit-unruly-apps</id>
    <content type="html"><![CDATA[<p>作为一个 UAC 和 sudo 爱好者，应用程序就应该乖乖的，该干嘛干嘛。老是有些游戏或者别的什么大言不惭的在安装说明叫你关掉 UAC，这一类要么是技术不好要么就是人品不好。今天就碰到一个。家里人要在网上打打麻将斗斗地主什么的，朋友们都在玩一个叫什么 <a href="http://www.jj.cn">JJ比赛</a> 的游戏，类似于腾讯的游戏大厅的东东。官网提供安装版和所谓绿色版，但是不管哪个版，只要一运行，UAC 提示框就会跳出来。我就纳闷了，一个游戏，要管理员权限干什么，而且我电脑上不是所有账户都有管理员权限。顺手看看到底是怎么回事：</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/TKLobby.exe_Manifest.png" title="manifest" ></p>

<p>看来不是 Windows 自动进行了兼容性修改，而是赤果果的 <code>RequireAdministrator</code>。本来这种程序直接删除了事，这次不行了，于是祭出 <a href="http://www.microsoft.com/download/en/details.aspx?id=7352">Microsoft Application Compatibility Toolkit</a>，是用于评估和改善应用程序的兼容性的，特别是针对 Vista 以后的 Windows。截图一枚：</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/Compatibility_Administrator.png" title="'Compatibility Administrator'" ></p>

<p>关键设置是加一条 <code>RunAsInvoker</code> 的修改，这些都可以根据向导一步步生成，最后安装这个 fix 到系统数据库就行了。</p>

<p>嗯，现在放心多了，普通账户也可以运行了。完。</p>

<p>注：不是所有的兼容性问题都可以这样解决，比如有些程序用了高权限的 API，那就没办法降低权限了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create a VLAN trunk in TL-WR703N]]></title>
    <link href="http://blog.haohaolee.com/blog/2012/03/24/create-a-vlan-trunk-in-tl-wr703n/"/>
    <updated>2012-03-24T20:57:00+08:00</updated>
    <id>http://blog.haohaolee.com/blog/2012/03/24/create-a-vlan-trunk-in-tl-wr703n</id>
    <content type="html"><![CDATA[<p><a href="http://wiki.openwrt.org/toh/tp-link/tl-wr703n">TL-WR703N</a> is a very tiny router, made by TP-LINK who markets it as &#8220;3G travel router&#8221;, although without a builtin 3G modem you cannot really say it is a 3G router, which is still an awesome device for its size. Very neat.</p>

<p><a href="http://wiki.openwrt.org/toh/tp-link/tl-wr703n">TL-WR703N</a> 是一个非常小的路由器，生产商 TP-LINK 把它宣传为 “3G 旅行路由器”，然而不自带 3G 猫芯的路由器不能算作真正意义上的 3g 设备，不过它仍然是非常赞的东东，因为实在太小巧了。</p>

<p><img src="http://www.tp-link.cn/pages/images/products/532px/series/TL-WR703N.jpg" title="TL-WR703N" ></p>

<p>There are many stories about how to make it a low power 24x7 <a href="https://forum.openwrt.org/viewtopic.php?pid=150596#p150596">downloading box</a>, or a <a href="https://forum.openwrt.org/viewtopic.php?pid=150597#p150597">wireless audio streaming box</a> with <a href="http://openwrt.org">OpenWrt</a>, I still wanna make it a better router. Since it has only one ethernet interface and has no switch built-in, therefore we often change its role as a normal router with wireless clients to a wireless bridge or repeater with wired clients. It would be cool if the only interface can automatically vary its role according to different situation. To be brief, our goal
is:</p>

<ol>
<li>When a node&#8217;s ethernet wire is plugged in, and makes DHCP requests, the router should assign it a LAN IP.</li>
<li>Otherwise, the router should consider the wire as an WAN path.</li>
</ol>


<p>网上有许多关于如何用 <a href="http://openwrt.org">OpenWrt</a> 把它做成一个低功耗 24x7 的<a href="https://forum.openwrt.org/viewtopic.php?pid=150596#p150596">下载机</a>，或者<a href="https://forum.openwrt.org/viewtopic.php?pid=150597#p150597">无线音乐播放设备</a>的故事。不过我还是只想尝试把它折腾成一个更好的路由器。因为只有一个以太网接口并且内部也没有交换机芯片，所以我们常常要在带无线客户端的路由器和带有线客户端的中继或者网桥之间转换。但是如果不需要配置就能自动切换这两种功能就更棒了。简单地说，我们的目标是：</p>

<ol>
<li>当有线客户端接入并且请求 DHCP 时，路由器应该分配给它一个 IP，并纳入 LAN。</li>
<li>其他情况，一律视作 WAN 接口。</li>
</ol>


<p>Currently, there is a <a href="http://www.right.com.cn/forum/thread-75532-1-1.html">solution</a> to this on the net is to leverage the linux kernel functionality macvlan, and make a virtual interface based on the physical interface with different MAC. This approach just works, but I don&#8217;t like the way it shares all the packets of LAN and WAN on the wire without discrimination, and OpenWrt has no uci config for macvlan so far. So I think <a href="http://en.wikipedia.org/wiki/VLAN">VLAN trunk</a> is a better way, at least for me. This approach needs configurations on the wired LAN clients, such as Computers and other linux routers. Since the typical applications of mine involve only my own devices, it&#8217;s not a big deal.</p>

<p>目前有一种<a href="http://www.right.com.cn/forum/thread-75532-1-1.html">方法</a>可以解决，就是利用 linux kernel 的 macvlan 功能，创建一个基于物理接口的虚拟接口，只是 MAC 不同。这种方法可以工作，不过我不喜欢它对数据包完全不加以区分的方式，并且 OpenWrt 没有专门针对的 macvlan 的配置文件。这种情况下我更倾向于 <a href="http://en.wikipedia.org/wiki/VLAN">VLAN trunk</a>。但是这种办法需要在客户端，比如电脑或者其他路由器上进行配置，不过我的典型应用只涉及到我自己的设备，所以这不是什么大问题。</p>

<p>The config on the OpenWrt side:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># /etc/config/network
</span><span class='line'>
</span><span class='line'>config interface 'loopback'
</span><span class='line'>    option ifname 'lo'
</span><span class='line'>    option proto 'static'
</span><span class='line'>    option ipaddr '127.0.0.1'
</span><span class='line'>    option netmask '255.0.0.0'
</span><span class='line'>
</span><span class='line'>config interface 'wan'
</span><span class='line'>    option proto 'dhcp'
</span><span class='line'>    option ifname 'eth0'
</span><span class='line'>
</span><span class='line'>config interface 'lan'
</span><span class='line'>    option type 'bridge'
</span><span class='line'>    option proto 'static'
</span><span class='line'>    option netmask '255.255.255.0'
</span><span class='line'>    option ipaddr '172.16.0.1'
</span><span class='line'>    option ifname 'eth0.2'
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># /etc/config/wireless
</span><span class='line'>
</span><span class='line'>config wifi-device 'radio0'
</span><span class='line'>    option type 'mac80211'
</span><span class='line'>    option macaddr 'xx:xx:xx:xx:xx:xx'
</span><span class='line'>    option hwmode '11ng'
</span><span class='line'>    option htmode 'HT20'
</span><span class='line'>    list ht_capab 'SHORT-GI-20'
</span><span class='line'>    list ht_capab 'SHORT-GI-40'
</span><span class='line'>    list ht_capab 'RX-STBC1'
</span><span class='line'>    list ht_capabb 'DSSS_CCK-40'
</span><span class='line'>    option txpower '27'
</span><span class='line'>    option country 'US'
</span><span class='line'>    option channel '11'
</span><span class='line'>
</span><span class='line'>config wifi-iface
</span><span class='line'>    option device 'radio0'
</span><span class='line'>    option mode 'ap'
</span><span class='line'>    option ssid 'OpenWrt'
</span><span class='line'>    option encryption 'none'
</span><span class='line'>    option network 'lan'</span></code></pre></td></tr></table></div></figure>


<p>eth0 is WAN, which should work without change; eth0.2 is a VLAN interface created by linux vconfig tagged with ID 2, which is not a hardware VLAN, and eth0.2 is bridged with wireless.</p>

<p>eth0 是 WAN 口，像往常一样不需变动；eth0.2 是 linux vconfig 创建的 VLAN 口, ID 为 2，并非硬件 VLAN，并且 eth0.2 和无线桥接到了一起。</p>

<p>On the client side, the configurations depend on the NIC driver. Most recent intel NICs have VLAN support with official drivers, so do the Realtek ones, but they need additional utility called <a href="http://www.realtek.com.tw/DOWNLOADS/downloadsView.aspx?Langid=1&amp;PNid=13&amp;PFid=4&amp;Level=5&amp;Conn=4&amp;DownTypeID=3&amp;GetDown=false&amp;Downloads=true">Windows Diagnostic Program</a> to do this. Here are screen shots:</p>

<p>在客户端这边，配置取决于网卡驱动，大部分现代的 Intel 网卡都支持 VLAN，Realtek 也支持，只不过需要专门的<a href="http://www.realtek.com.tw/DOWNLOADS/downloadsView.aspx?Langid=1&amp;PNid=13&amp;PFid=4&amp;Level=5&amp;Conn=4&amp;DownTypeID=3&amp;GetDown=false&amp;Downloads=true">工具</a>来进行配置。截图几枚：</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/Realtek_Ethernet_Diagnostic_Utility.png" title="VLAN" >
<img src="https://dl.dropbox.com/u/1950964/img/VLAN%202%20Properties.png" title="NIC" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TIL what the emplace operation is in C++11]]></title>
    <link href="http://blog.haohaolee.com/blog/2012/03/11/til-what-emplace-is-in-c-plus-plus-11/"/>
    <updated>2012-03-11T14:03:00+08:00</updated>
    <id>http://blog.haohaolee.com/blog/2012/03/11/til-what-emplace-is-in-c-plus-plus-11</id>
    <content type="html"><![CDATA[<p>There are some new operations added to STL containers in C++11, which include <code>emplace</code>, <code>emplace_hint</code>, <code>emplace_front</code>, <code>emplace_after</code> and <code>emplace_back</code>.</p>

<p>Nearly all containers in STL have this kind of operations except <code>std::array</code>, because it&#8217;s immutable. All these operations share the common characteristic, which is &#8216;constructing elements in containers directly without copy or move&#8217;.</p>

<h2>Motivation</h2>

<p>Since C++11 introduced <a href="http://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors">rvalue-reference</a> and its moveable semantic, although a big improvement on performance, sometimes there are still some redundant copy operations. For instance, say we have:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">,</span> <span class="mf">2.71828</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>First, the tuple is a <a href="http://en.wikipedia.org/wiki/C%2B%2B11#Modification_to_the_definition_of_plain_old_data">POD</a>, therefore no movable constructor, actually it is obvious you cannot move anything from within a POD object. The above code may make some copies of the tuple which depends on the compiler optimaztion.</p>

<p>Second, even when operating on moveable object, some copies still cannot be avoided. You can move a vector, but you still need copy the internal pointer that holds the resource.</p>

<p>Emplace can do better for this, thanks to <a href="http://en.wikipedia.org/wiki/C%2B%2B11#Variadic_templates">variadic template</a> and the perfect forwarding. Instead of the above code, we can do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">,</span> <span class="mf">2.71828</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here emplace_back will forward all the parameters to some internal function where the vector constructs its elements, just like what a <code>tuple&lt;int, double, long double&gt; t(2, 3.14, 2.71828);</code> does. No copies, no moves, constructs directly.</p>

<p>Another example</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vec_2d</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// add a vector filled with five ones</span>
</span><span class='line'>
</span><span class='line'><span class="n">vec_2d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="c1">// using push_back, and expect to move</span>
</span><span class='line'>
</span><span class='line'><span class="n">vec_2d</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//or using emplace_back, constructing it directly</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note you only need provide the parameters for the element&#8217;s constructor by order.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++2011 Memory Model 笔记]]></title>
    <link href="http://blog.haohaolee.com/blog/2011/07/25/cpp2011-memory-model-notes/"/>
    <updated>2011-07-25T00:10:18+08:00</updated>
    <id>http://blog.haohaolee.com/blog/2011/07/25/cpp2011-memory-model-notes</id>
    <content type="html"><![CDATA[<p>C++0x 的内存模型怕是 0x 里面最难啃的骨头之一了吧，至少相对于那些语法糖的增加来说。每次回来看都有些新的收获，这里做个记录。没有系统地总结，尽量给出处吧。标准参考的是 <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">n3291</a>，和 FDIS 是一样的。</p>

<h2>Memory ordering</h2>

<p>C++ 的内存模型有3种 Memory Ordering</p>

<ol>
<li><p>sequential-consistent ordering</p></li>
<li><p>acquire-release ordering</p></li>
<li><p>relaxed ordering</p></li>
</ol>


<p>标准中对 atomic type 的 order 定义如下(29.3)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">typedef</span> <span class="k">enum</span> <span class="n">memory_order</span> <span class="p">{</span>
</span><span class='line'>       <span class="n">memory_order_relaxed</span><span class="p">,</span> <span class="c1">// relaxed ordering</span>
</span><span class='line'>       <span class="n">memory_order_consume</span><span class="p">,</span> <span class="c1">// acquire-release ordering (acquire part)</span>
</span><span class='line'>       <span class="n">memory_order_acquire</span><span class="p">,</span> <span class="c1">// acquire-release ordering (acquire part)</span>
</span><span class='line'>       <span class="n">memory_order_release</span><span class="p">,</span> <span class="c1">// acquire-release ordering (release part)</span>
</span><span class='line'>       <span class="n">memory_order_acq_rel</span><span class="p">,</span> <span class="c1">// acquire-release ordering (both)</span>
</span><span class='line'>       <span class="n">memory_order_seq_cst</span>  <span class="c1">// sequential-consistent ordering</span>
</span><span class='line'>     <span class="p">}</span> <span class="n">memory_order</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>默认是 <code>memory_order_seq_cst</code>，也就是 sequential-consistent，注意这里说的都是针对 atomic types。因为 C++ 标准不允许 non-atomic 的 data race，包含 data race 的程序视为 undefined behavior(1.10-21)。所以解决潜在的 data race 必须依赖 locks 以及 atomic operation。<strong>再强调一下，C++11 中凡是非 atomic type 的 data race 都是未定义行为，程序不可移植，等价于错误的程序</strong>。lock 这里不谈，因为使用上是符合直觉以及传统的，目的就是保护好 shared 对象，防止 data race。</p>

<h2>Seqential Consistent Ordering</h2>

<p>默认的 sequential-consistent model 是沿袭 Java 的内存模型(确切的说是 sequential-consistent with data-race-free)，所有的 atomic 操作都可以看作满足唯一 total order 的操作，也就是说，可以把这样的多线程程序理解成一个有先有后交叉运行的单线程程序(对atomic type而言)，这在推理时是有帮助的。每个 shared atomic 对象的改变在每个线程看来都是一样的，包括时间顺序以及值。这样一个默认的模型是相对来说符合直觉和容易处理的。举一个 <a href="http://en.wikipedia.org/wiki/Double-checked_locking">Double-checked locking</a> 的例子。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="k">class</span> <span class="nc">singleton</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
</span><span class='line'>        <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">expensive_data</span> <span class="o">*&gt;</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="c1">// initialize data to 0 in constructor</span>
</span><span class='line'>    <span class="c1">//.....</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">expensive_data</span><span class="o">*</span> <span class="n">get_instance</span><span class="p">()</span> <span class="k">const</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">expensive_data</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</span><span class='line'>                <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
</span><span class='line'>                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">expensive_data</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">data</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的 load 和 store 默认参数都是<code>memory_order_seq_cst</code>, 等价于调用 <code>data.load(std::memory_order_seq_cst)</code> 和 <code>data.store(result, std::memory_order_seq_cst)</code>。</p>

<ol>
<li><p>shared data 要么在 mutex 内部，要么必须是 atomic type</p></li>
<li><p>这个正确实现是符合直觉的，而且它和其它平台(比如 Java)的实现几乎是一样的。只要不考虑其它的 ordering，正确性相对容易保证。</p></li>
</ol>


<p>结论：默认的 sequential consistent 语义虽然相对保守，但是容易写出正确的程序，这也是推荐的处理方式。不到万不得已(性能不可接受)，不要使用其它语义，即上面提到的另外两种 ordering</p>

<h2>Relaxed Memory Ordering</h2>

<p>一旦进入剩下两种 ordering 的世界，程序的编写就得格外小心——因为它处处违反直觉。举标准一例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="c1">// Thread 1:</span>
</span><span class='line'>    <span class="n">r1</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Thread 2:</span>
</span><span class='line'>    <span class="n">r2</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>x,y 初始值为0，该程序结果不唯一，这是显而易见的。但是 r1 == r2 == 42 也是一个正确的结果，是不是很违反直觉？要产生这个结果，那么实际顺序必须是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">r1</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">r2</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li><p>对于 thread 1 而言，thread 2 的执行不是顺序的(所谓的 program order)</p></li>
<li><p>整体顺序完全不确定，这4条指令完全可以以任意顺序排列(实际执行也许根本不是 sequential 的)</p></li>
</ol>


<p>relaxed ordering 是最松散的一种语义：</p>

<ul>
<li><p>完全不参与多线程间的同步，编译器可以随便优化</p></li>
<li><p>对于自身线程，data-dependency 产生的依赖需要满足，这是单线程程序正确性的要求</p></li>
<li><p>此外它唯一的作用就是属于原子操作，所以不会产生 data race</p></li>
</ul>


<h2>Acquire-Release Ordering</h2>

<p>该语义即同步语义，每一个 acquire 对应一个 release(跨线程的)，详细定义参见标准(29.3-2)。需要注意的是 C++ 的同步语义不是先验的，我们无法通过之前的执行判断之后两个操作是否同步了，而只能通过推理所有的情况来验证程序的正确性。具体来说，对于一个可能的 acquire-release pair，我必须考虑他们同步时的情况，也需要考虑他们没有同步时的情况。推理 C++ 多线程程序的正确性，特别是在这两种 ordering 情况下，需要塑模 happens-before 的关系(标准1.10-12)，通俗点说，就是推理出相关操作之间所有可能发生的顺序(或者根本就无序)。所以说带锁的多线程的程序很难写正确，更别说无锁的，可见一斑。
举例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="c1">// x0, x1 is atomic bool and initialized to false</span>
</span><span class='line'>    <span class="c1">// victim is atomic int and initialized to 0</span>
</span><span class='line'>    <span class="c1">// Thread 0</span>
</span><span class='line'>    <span class="n">x0</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">r0</span> <span class="o">=</span> <span class="n">victim</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span><span class='line'>    <span class="n">r1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Thread 1</span>
</span><span class='line'>    <span class="n">x1</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>    <span class="n">r2</span> <span class="o">=</span> <span class="n">victim</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span><span class='line'>    <span class="n">r3</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>如何分析线程间可能的同步状态？因为 acquire 要和 release 对应，而两个线程中唯一可能同步的就是 victim 变量了，因为它的 exchange(即 read-modify-write 操作) 是 <code>memory_order_acq_req</code>，先读后写，读时 acquire，写时 release。这里先总结相关要点：</p>

<ol>
<li><p>当一个 atomic 对象的 acquire 同步 release 时(不同线程)，acquire 读到的值不一定是 release 上次写的值(不保证cache-coherence)，也可能是之前该 atomic 对象的值。准确的说，对于一个 atomic 对象，它存在唯一一个 modification order，即该对象从诞生以来被修改的顺序，可以想成一个 list {init, x1, x2, x3, &#8230;}。而 acquire 读到的值可以是从上次读取到最近修改中间任意一个(包括上次读取的值)。假如 acquire 这次读到一个值 x1，那么下次 acquire 就可能读到 x1, x2, x3 等等，但是不可能读到 init 了。</p></li>
<li><p>read-modify-write 操作含有特殊的语义，它每次都可以读到该 atomic 变量的最新的值。所以当该类操作同步时，读到的都是 modification order 最后的值。</p>

<ul>
<li><p>如果线程0中的 victim 读到 1，即 r0 返回 1，说明和线程1的 victim 写入同步，我们可以推理如下，按时间顺序:</p>

<ol>
<li><p>线程1中 &#8220;x1 置为 true&#8221; happens before &#8220;victim 置为 1&#8221;，这是 program order 保证的</p></li>
<li><p>线程1中 &#8220;victim 置为 1&#8221; happens before 线程0 &#8220;victim exchange&#8221;，这是同步</p></li>
<li><p>线程0中 &#8220;victim 读到 1，然后置为 0&#8221; happens before &#8220;x1 load&#8221;</p></li>
</ol>
</li>
</ul>


<p> 所以结论是 r1 == true r2 == 1，而 r3 未知，可以是 true，也可以是初始值 false，因为他们没有同步关系。</p>

<ul>
<li><p>如果线程0中的 victim 读到 0，即 r0 返回 1，那么 victim 读取的是初始值 0，那么反过来线程1的 victim 就会读到线程0 的 victim 值了：</p>

<ol>
<li><p>线程0中 &#8220;x0 置为 true&#8221; happens before &#8220;victim 置为 0&#8221;</p></li>
<li><p>线程0中 &#8220;victim 置为 0&#8221; happens before 线程1中 &#8220;victim exchange&#8221;</p></li>
<li><p>线程1中 &#8220;victim 读到 0，然后置为 1&#8221; happens before &#8220;x0 load&#8221;</p></li>
</ol>
</li>
</ul>


<p> 所以结论是 r3 == true r2 == 0，r1 是不确定的。</p></li>
</ol>


<p>这里只有两个线程，同时各执行一次，atomic 修改的次数也不多。所以推理起来尚属容易。</p>

<h2>Peterson&#8217;s lock</h2>

<p>最后以一个 <a href="http://en.wikipedia.org/wiki/Peterson's_algorithm">Peterson&#8217;s lock</a> 为例结束本文。该例是从 <a href="http://www.justsoftwaresolutions.co.uk/threading/petersons_lock_with_C++0x_atomics.html">这篇blog</a> 抄来的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flag0</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">flag1</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">turn</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">lock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">flag0</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>            <span class="n">turn</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">while</span> <span class="p">(</span><span class="n">flag1</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span>
</span><span class='line'>                <span class="o">&amp;&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">turn</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">flag1</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span><span class='line'>            <span class="n">turn</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">while</span> <span class="p">(</span><span class="n">flag0</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span>
</span><span class='line'>                <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">turn</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span>
</span><span class='line'>                <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">unlock</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">index</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">flag0</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">flag1</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Peterson lock 是最简单的锁实现之一，它只提供两个线程之间的锁同步。该实现为了追求性能，采用了更弱的 ordering，所以这意味着正确性需要严格的证明。这里只总结一下要点：</p>

<ol>
<li><p>代码并非处处使用 acquire-release 同步，也有使用 relaxed ordering 的地方，但是正确性需要严格证明</p></li>
<li><p>正确的关键在 <code>turn.exchange</code> 的使用和处理，<code>exchange</code> 保证了读取的值是最近修改的，而 <code>memory_order_acq_rel</code> 则保证了同步，从而使得跨线程的 happens-before 关系正确建立，并且 <code>while</code> 循环里 <code>turn</code> 和 <code>flag</code> 可以读到最新的值</p></li>
</ol>


<p>完整的证明可以参考<a href="http://www.justsoftwaresolutions.co.uk/threading/petersons_lock_with_C++0x_atomics.html">出处</a>。</p>

<p>值得一提的是，如果采用 sequential-consistent ordering —— <code>flag</code> 和 <code>turn</code> 都用 <code>memory_order_seq_cst</code> 的话 —— 立刻就得到一个正确的实现，这也是目前大多数 peterson lock 的实现。基于 sequential-consistent 的 peterson lock 证明也更容易，可以参考 <a href="http://www.amazon.com/Art-Multiprocessor-Programming-Maurice-Herlihy/dp/0123705916"><em>The Art of Multiprocessor Programming</em></a> 第二章。</p>

<p>本文参考:</p>

<ol>
<li><p><a href="http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/">C++ atomics and memory ordering</a></p></li>
<li><p><a href="http://bartoszmilewski.wordpress.com/2008/12/23/the-inscrutable-c-memory-model/">The Inscrutable C++ Memory Model</a></p></li>
<li><p><a href="http://www.justsoftwaresolutions.co.uk/threading/petersons_lock_with_C++0x_atomics.html">Peterson&#8217;s lock with C++0x atomics</a></p></li>
<li><p><a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf">n3291</a></p></li>
<li><p><a href="http://www.parallellabs.com/2010/03/06/why-should-programmer-care-about-sequential-consistency-rather-than-cache-coherence/">为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？）</a></p></li>
</ol>


<p>Posted via <a href="http://sinolog.it/?p=1894">UltraBlog.vim</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 StrongSwan 搭建 ipsec VPN (2) For iOS]]></title>
    <link href="http://blog.haohaolee.com/blog/2011/05/12/use-strongswan-to-build-ipsec-vpn-for-ios/"/>
    <updated>2011-05-12T21:11:27+08:00</updated>
    <id>http://blog.haohaolee.com/blog/2011/05/12/use-strongswan-to-build-ipsec-vpn-for-ios</id>
    <content type="html"><![CDATA[<p>再不写这个 part 2，搞不好就胎死腹中了。好嘛，书接上回，这次我们在 <a href="https://haohaolee.com/blog/2011/04/%E4%BD%BF%E7%94%A8-strongswan-%E6%90%AD%E5%BB%BA-ipsec-vpn-1-for-nokia-mobile-vpn-client/">part 1</a> 的基础上搭建一个 iOS 可以用的 ipsec VPN。</p>

<p>iOS 其实还可以用 L2TP VPN，这里且不谈我对 L2TP over ipsec 的无尽bs，如果要支持手上众多设备，还是采用纯 ipsec 的解决方案比较好。顺便吐个槽，窃以为支不支持以 Cisco 为代表的众多商用 VPN 服务器是一个移动设备是否成熟到胜任商业应用的标准，对，说的就是你，<em>Android</em> 。人家 iOS 和塞班都支持，你都出道几年了？看不到<a href="http://code.google.com/p/android/issues/detail?id=3902">怨声载道</a>吗？</p>

<h2>正文</h2>

<ul>
<li>服务器</li>
</ul>


<p>首先在 part 1 的基础上，修改三个配置文件就 OK 了：</p>

<p>ipsec.conf:</p>

<p>在配置文件把 setup 一节开头添加两行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>config setup
</span><span class='line'>    # add pluto for ikev1
</span><span class='line'>    plutostart=yes
</span><span class='line'>    nat_traversal=yes  
</span><span class='line'>    strictcrlpolicy=no
</span><span class='line'>    charonstart=yes
</span><span class='line'>    uniqueids=yes</span></code></pre></td></tr></table></div></figure>


<p>然后在末尾添加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>conn ipad
</span><span class='line'>    type=tunnel
</span><span class='line'>    authby=xauthrsasig
</span><span class='line'>    xauth=server
</span><span class='line'>    keyexchange=ikev1
</span><span class='line'>    ike=aes128-md5-modp1024
</span><span class='line'>    esp=aes128-md5
</span><span class='line'>    auto=add
</span><span class='line'>    modeconfig=push
</span><span class='line'>    compress=yes
</span><span class='line'>    dpdaction=clear
</span><span class='line'>    pfs=no
</span><span class='line'>    leftcert=strongswan.crt
</span><span class='line'>    leftsubnet=0.0.0.0/0
</span><span class='line'>    right=%any
</span><span class='line'>    rightsourceip=192.168.66.248/29
</span><span class='line'>    rightca=%same</span></code></pre></td></tr></table></div></figure>


<p>注意到 <code>authby=xauthrsasig</code> 这一行，因为 iOS 设备采用 rsa + xauth 的混合认证，需要同时配置证书和密码认证。服务器端证书 strongswan.crt 的颁发和配置参考 part 1 的说明。同样的，ip 地址段按自己喜好随意，因为 part 1 已经配置了一个 ip 段，这里就复用一下，防火墙的配置也可以省省了。</p>

<p>ipsec.secret:</p>

<p>同上，在末尾添加：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>username : XAUTH "password"</span></code></pre></td></tr></table></div></figure>


<p>用户名和密码自己随意，其他保持不变</p>

<p>strongswan.conf:</p>

<p>修改 <code>pluto</code> 一项为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pluto {
</span><span class='line'>    dns1 = 8.8.8.8
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里一样加上 google 的 dns 以防万一客户端没有被推送到默认的 dns</p>

<ul>
<li>客户端</li>
</ul>


<p>首先按照 part 1 证书一节所述，给你的 iOS 设备颁发证书，假设得到的是 iOS.p12，然后把该文件和 ca.crt (iOS 对证书格式要求不高，不一定要是 der) 一起传到设备上。我习惯通过 email，然后在 safari 里面点击附件就可以安装了。</p>

<p>最后的最后，还是截个图了事，一图胜千言啊：</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/ipad.png" title="ipad" ></p>

<p>设置的时候选择你刚刚安装的证书就行了。</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/ipad2.png" title="ipad2" ></p>

<p>update 2011/5/21: 这里有一份官方 wiki 专门讲 iOS 配置，一并参考: <a href="http://wiki.strongswan.org/projects/strongswan/wiki/IOS_(Apple">http://wiki.strongswan.org/projects/strongswan/wiki/IOS_(Apple)</a>)</p>

<p>如果你觉得这篇文章有用，可以考虑给我点 <a href="http://www.bitcoin.org">Bitcoin</a> 小费: 14kB4s43d1CNy4VipGfpfennivJAgHkEnK</p>

<p>Posted via <a href="http://sinolog.it/?p=1894">UltraBlog.vim</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 StrongSwan 搭建 ipsec VPN (1) For Nokia Mobile VPN Client]]></title>
    <link href="http://blog.haohaolee.com/blog/2011/04/13/use-strongswan-to-build-ipsec-vpn-for-nokia-mobile-vpn-client/"/>
    <updated>2011-04-13T00:46:09+08:00</updated>
    <id>http://blog.haohaolee.com/blog/2011/04/13/use-strongswan-to-build-ipsec-vpn-for-nokia-mobile-vpn-client</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>话说如今这年头，翻墙已经不是要不要，而是怎么翻的问题。所以网上各种免费的收费的代理VPN满天飞，活生生在天朝创造了一个新兴的市场。可是对于使用 nokia s60 的用户来讲，各种不方便啊。ssh 代理不好用，vpn 呢官方客户端只支持 ipsec，还有个商业客户端 symVPN 支持 pptp 但是太贵且<a href="http://www.google.com/search?hl=zh-CN&amp;newwindow=1&amp;safe=strict&amp;q=%E5%B0%81%E9%94%81+pptp&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=">不实用</a>。经过大半个月的摸索，笔者最终使用开源软件 <a href="http://www.strongswan.org">strongSwan</a> 成功搭建了 Nokia S60 3rd 可以使用的VPN服务器。(理论上 v5 symbian<sup>3</sup> 应该也行，只要使用的是 <a href="http://europe.nokia.com/support/download-software/nokia-mobile-vpn">Nokia Mobile VPN</a>，Maemo 就不提了)。</p>

<p>网上有关搭建Nokia VPN的中文文章据我所知只有 alpha2beta <a href="http://www.alpha2beta.com/vpn/vpn-on-nokia-s60-2-openswan-and-vpn-policy.html">这一篇</a>，该文采用的是 <a href="http://www.openswan.org">openswan</a>，和 strongswan 其实差不太多，都实现了 ipsec 协议。强烈推荐先去那里看看，如果：</p>

<ol>
<li>你想要快速搭建一个 Nokia 手机可用的 VPN，因为那篇文章采用的是 PSK 认证(pre-shared keys)，所以相对来说准备工作和步骤要少很多，实际上会容易一些</li>
<li>你并不需要同时支持其它客户端，比如 iOS，Windows 等等</li>
</ol>


<p>如果你和笔者一样需要支持手头上的众多设备，那么请继续往下看吧。在本文基础上，可以很容易添加其它的设备。不过请做好心理准备，因为 ipsec 是公认的难搞，再加上 Nokia 设备的极度不友好，所以请一定要有耐心。笔者曾经碰到到相同的配置应用到 Nokia 上，第一次行第二次不行的情况，实在是太诡异了。</p>

<p>不过搞定 ipsec 的一个好处是，ipsec 这样一个古老标准有着极其广泛的支持，几乎所有支持 VPN 的客户端原生支持着某种 ipsec 协议(大多数是兼容 Cisco 的 VPN 或者 L2TP over ipsec)，不像 openvpn 或者 pptp 配置起来很容易，但是往往设备不支持或者需要另外安装。</p>

<h2>本文假设</h2>

<ol>
<li><p>基本的 linux 使用经验，会 make，会 build，会查 log，会配 iptables，当然您也可以现在就学起来~</p></li>
<li><p>有一台 public ip 的linux服务器，如果是 VPS 最好是 xen 的( openvz 似乎不能安装 strongSwan )，并且服务器的<strong>public ip 是分配在某个 interface 上</strong>的，比如eth0，这意味服务器不能在NAT后面。(在NAT后面其实也是可以的，但是那会涉及到更多复杂的情况，本文不考虑，好在如今VPS不是都像EC2这样玩的)</p></li>
<li><p>有一个指向该 ip 的域名</p></li>
</ol>


<h2>步骤</h2>

<ul>
<li><p>建立自己的 CA &amp; 颁发证书</p></li>
<li><p>安装&amp;配置 StrongSwan</p></li>
<li><p>配置手机客户端</p></li>
<li><p>杂项</p></li>
</ul>


<h3>建立自己的 CA &amp; 颁发证书</h3>

<p>因为针对不同设备需要不同的配置，而 psk 是共享同一个密钥，所以服务器无法区分客户端。因此我们需要采用 x.509 证书认证。关于 x.509 体系的具体情况，请查阅相关资料，笔者也不是这方面的专家，不敢误人子弟。大致来说，就是通过同时颁发证书给服务器和客户端使它们互相信任并且识别对方，达到认证的目的，另外好处是比密码更安全。</p>

<p>颁发证书一般都采用 openssl。为了简便，尽量少的涉及到细节，这里采用 easy-rsa —— 一套脚本来完成这种任务。OpenVPN 项目就含有这一套脚本，这里以 linux 下的操作为例。Windows 的 OpenVPN 安装包也可以完成类似任务，不赘述。</p>

<p>将 easy-rsa 目录 copy 到你的工作目录，比如 $HOME 。easy-rsa 一般在 OpenVPN 的例子目录中，比如 /usr/share/openvpn/easy-rsa ，然后进入easy-rsa。我们需要修改两个文件:</p>

<ul>
<li>openssl.cnf (如果 openssl 的版本是0.9.6，那就是修改openssl-0.9.6.cnf) 以下带有注释的行是需要增加或者修改的:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>......
</span><span class='line'>subjectKeyIdentifier=hash
</span><span class='line'>authorityKeyIdentifier=keyid,issuer:always
</span><span class='line'>extendedKeyUsage=clientAuth      # add or modify this line
</span><span class='line'>......
</span><span class='line'>......
</span><span class='line'>[ server ]
</span><span class='line'>
</span><span class='line'># JY ADDED -- Make a cert with nsCertType set to "server"
</span><span class='line'>basicConstraints=CA:FALSE
</span><span class='line'>nsCertType          = server
</span><span class='line'>nsComment           = "OpenSSL Generated Server Certificate"
</span><span class='line'>subjectKeyIdentifier=hash
</span><span class='line'>authorityKeyIdentifier=keyid,issuer:always
</span><span class='line'>extendedKeyUsage=clientAuth, serverAuth, 1.3.6.1.5.5.8.2.2   # add or modify this line
</span><span class='line'>subjectAltName=DNS:your.vpn.domain                           # replace with your domain
</span><span class='line'>......</span></code></pre></td></tr></table></div></figure>


<p>subjectAltName 可以指定为 ip 或者域名，域名显然更灵活一些</p>

<ul>
<li>vars 修改最后几行，主要是证书的名称，机构，email等等，对应你自己的情况。例如:</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export KEY_COUNTRY="TC"
</span><span class='line'>export KEY_PROVINCE="HX"
</span><span class='line'>export KEY_CITY="modu"
</span><span class='line'>export KEY_ORG=""
</span><span class='line'>export KEY_EMAIL="whatever@xxx.com"</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>另外，KEY_SIZE 可以是1024也可以是2048，2048理论上更安全一些。</p>

<p>然后，执行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>. ./vars
</span><span class='line'>./clean-all
</span><span class='line'>./build-dh
</span><span class='line'>./build-ca</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>过程中会问你一些问题，因为上面设置过了，大多数可以直接回车。
末了，会在 keys 目录下生成 ca.crt 和 ca.key，前者是证书，后者是 key，key 是不能公开的</p>

<p>然后，继续:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./build-key-server your.vpn.domain</span></code></pre></td></tr></table></div></figure>


<p>替换 your.vpn.domain 为你自己的域名。生成一大堆东西，我们需要的包括 your.vpn.domain.crt 和 your.vpn.domain.key，这里用域名的原因是证书中的 common name 需要指定域名，作为参数传进去省事；当然你也可以手动指定。</p>

<p>继续：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./build-key-pkcs12 client_name</span></code></pre></td></tr></table></div></figure>


<p>过程和 server 的差不多，末了，会让你输入一个密码。这个密码是用来打包证书和 key 的。目录下会产生 client_name.crt，client_name.key 以及 client_name.p12</p>

<p>最后还有一步，执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>openssl x509 -inform PEM -outform DER -in keys/ca.crt -out keys/ca.cer</span></code></pre></td></tr></table></div></figure>


<p>这一步其实是 Symbian 需要的，它只能识别 der 格式，所以需要转换一下。
这样，CA 和证书就弄好了，这里我们建立了一个 root CA，一对服务器 证书/密钥， 一对客户端 证书/密钥。注意一定要保存好 keys 目录的现场，因为以后还需要颁发更多的证书。下文中我将 your.vpn.domain.crt/key 改名为 strongswan.crt/key， 客户端则假设为 E71.crt/key/p12</p>

<h3>安装&amp;配置 strongSwan</h3>

<p>strongSwan 我使用的最新的 release <a href="http://www.strongswan.org/download.html">4.5.1</a>，你可以使用自己的 distro 自带的版本，也可以自行 build，这里略过。唯一需要注意的是，你使用的版本最好支持 NAT traversal，虽然对于本文针对的 Nokia VPN 的情况下不一定需要，但是很多情况下客户端在 NAT 后面并且使用 ikev1 的时候是需要的(特别是以后关于 iOS 的部分)。 NAT traversal 是由一个编译选项 enable-nat-transport 决定的。这里给我 build 时使用的 config 作为参考：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./configure   --prefix=/usr --sysconfdir=/etc --libexecdir=/usr/lib \
</span><span class='line'>              --with-ipsecdir=/usr/lib/strongswan \
</span><span class='line'>              --enable-sqlite --enable-smartcard --enable-cisco-quirks \
</span><span class='line'>              --enable-openssl --enable-curl \
</span><span class='line'>              --enable-sql --enable-attr-sql \
</span><span class='line'>              --enable-farp --enable-dhcp \
</span><span class='line'>              --enable-eap-sim --enable-eap-sim-file --enable-eap-simaka-pseudonym \
</span><span class='line'>              --enable-eap-simaka-reauth --enable-eap-identity --enable-eap-md5 \
</span><span class='line'>              --enable-eap-gtc --enable-eap-aka --enable-eap-aka-3gpp2 \
</span><span class='line'>              --enable-eap-mschapv2 --enable-eap-radius \
</span><span class='line'>              --enable-ha \
</span><span class='line'>              --enable-nat-transport \
</span><span class='line'>              --disable-mysql --disable-ldap \
</span><span class='line'>              --disable-static --enable-shared</span></code></pre></td></tr></table></div></figure>


<p>安装好以后，可以看看是否存在 ipsec 命令，以及是否存在 /etc/ipsec.d/ 目录</p>

<ul>
<li><p>安装证书
这里我们需要的证书和密钥包括 ca.crt，strongswan.crt，strongswan.key。
将 ca.crt copy 到 /etc/ipsec.d/cacerts/ ，strongswan.crt copy 到 /etc/ipsec.d/certs/ ，strongswan.key copy 到 /etc/ipsec.d/private/</p></li>
<li><p>配置
/etc/ipsec.conf</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># ipsec.conf - strongSwan IPsec configuration file
</span><span class='line'>
</span><span class='line'>config setup
</span><span class='line'>    strictcrlpolicy=no
</span><span class='line'>    charonstart=yes
</span><span class='line'>    uniqueids=yes
</span><span class='line'>
</span><span class='line'>conn %default
</span><span class='line'>    authby=rsasig
</span><span class='line'>    leftrsasigkey=%cert
</span><span class='line'>    rightrsasigkey=%cert
</span><span class='line'>    left=%defaultroute
</span><span class='line'>
</span><span class='line'>conn ikev2
</span><span class='line'>    keyexchange=ikev2
</span><span class='line'>    leftsubnet=0.0.0.0/0
</span><span class='line'>    leftcert=strongswan.crt
</span><span class='line'>    rightca=%same
</span><span class='line'>    dpddelay=90
</span><span class='line'>    dpdtimeout=90
</span><span class='line'>    dpdaction=clear
</span><span class='line'>    right=%any
</span><span class='line'>    rightsourceip=192.168.66.240/29
</span><span class='line'>    auto=add</span></code></pre></td></tr></table></div></figure>


<p>这里 192 打头的地址段是分配给客户端的虚拟 ip，你可以任意配置，我这里掩码用了29 bit，所以同时支持的客户端只有8个</p>

<p>/etc/strongswan.conf</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># strongswan.conf - strongSwan configuration file
</span><span class='line'>
</span><span class='line'>charon {
</span><span class='line'>    # number of worker threads in charon
</span><span class='line'>    threads = 16
</span><span class='line'>
</span><span class='line'>    # send strongswan vendor ID?
</span><span class='line'>    # send_vendor_id = yes
</span><span class='line'>
</span><span class='line'>    dns1 = 8.8.8.8
</span><span class='line'>
</span><span class='line'>    filelog {
</span><span class='line'>            /var/log/charon.log {
</span><span class='line'>                # loggers to files also accept the append option to open files in
</span><span class='line'>                # append mode at startup (default is yes)
</span><span class='line'>                # the default loglevel for all daemon subsystems (defaults to 1).
</span><span class='line'>                default = 1
</span><span class='line'>            }
</span><span class='line'>            stderr {
</span><span class='line'>                # more detailed loglevel for a specific subsystem, overriding the
</span><span class='line'>                # default loglevel.
</span><span class='line'>                ike = 2
</span><span class='line'>                knl = 3
</span><span class='line'>            }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    plugins {
</span><span class='line'>
</span><span class='line'>            sql {
</span><span class='line'>              # loglevel to log into sql database
</span><span class='line'>              loglevel = -1
</span><span class='line'>
</span><span class='line'>              # URI to the database
</span><span class='line'>              # database = sqlite:///path/to/file.db
</span><span class='line'>              # database = mysql://user:password@localhost/database
</span><span class='line'>          }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>pluto {
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>libstrongswan {
</span><span class='line'>
</span><span class='line'>    #  set to no, the DH exponent size is optimized
</span><span class='line'>    #  dh_exponent_ansi_x9_42 = no
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>dns1 是 push 到客户端的 dns，这里用的 google anycast dns，另外 filelog 是一些 log 选项</p>

<p>/etc/ipsec.secrets</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>: RSA /etc/ipsec.d/private/strongswan.key</span></code></pre></td></tr></table></div></figure>


<p>这里指定的是服务器使用的密钥，冒号之前可以用具体的 ip 来限制客户端，这里表示任意客户端。</p>

<ul>
<li>防火墙
ipsec 需要打开 udp 500，udp 4500，ESP (协议号50)，AH (协议号51).
你还需要将服务器配置为一个路由器(如果不是的话)，这意味你需要打开 ip 转发，并且要为你的虚拟 ip 段做 SNAT (除非你玩的是ipv6)。这部分内容请参考其他资料，一般不同的发行版都有专门文档阐述。</li>
</ul>


<p>你可以尝试启动 ipsec 服务，如果没有错误信息的话，服务器就配置好了。log 信息是在 /var/log 下面 auth.log 以及 charon.log</p>

<h3>配置手机客户端</h3>

<p>Nokia Mobile VPN Client，E系列我记得是自带的，其他手机可能要手动下载安装。另外，这里讨论的客户端版本>=3.1，因为3.1之后的客户端支持用一个后缀为 vpn 的 zip 包作为 vpn 策略文件，很方便。之前的版本需要创建 sis 文件，搞不好还要签名。所以这里只考虑3.1以后的。据我所知大都能升级到至少3.1。</p>

<p>目前网上的文章都是基于手工制作 vpn 策略文件，很容易出错。所幸我找到一个官方的程序可以自动生成策略文件，减少了出错的可能。</p>

<p><a href="http://nds1.nokia.com/files/support/global/phones/software/Nokia_VPN_Client_Policy_Tool.msi">下载地址</a> 需要 .Net Framwork 2.0</p>

<p>现在切换到 Windows 平台下面。准备以下文件 ca.cer (不是ca.crt)，E71.p12，都是建立 CA 时生成的。过程都用截图算了，很简单。在 vista 和 win7 下需要管理员权限来执行。</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/wizard.png" title="wizard" ></p>

<p>注意正确替换你的域名或ip</p>

<p><img src="https://dl.dropbox.com/u/1950964/img/advance.png" title="advance" ></p>

<p>将 cert store 改为 DEVICE，这样不用每次启动 VPN 都要输入密码</p>

<p>然后执行 generate VPN policy，就OK了。至于如何安装及其设置接入点，网上已有很多资料，不再赘述。比如<a href="http://www.alpha2beta.com/vpn/%E5%9C%A8%E8%AF%BA%E5%9F%BA%E4%BA%9As60%E6%89%8B%E6%9C%BA%E4%B8%8A%E4%BD%BF%E7%94%A8vpn%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%8E%9F%E7%94%9F%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B4%E6%98%8E%E5%8F%8A12vpn%E8%AF%84.html">这里</a>，<a href="http://429006.com/article/technology/2140.htm">这里</a>。</p>

<p>设置好接入点之后就可以测试了。
如果连接失败了，一方面需要看手机上的日志(虽然信息量有限)，另一方面需要看服务器上日志，特别是 charon.log，这是 ikev2 的日志。
如果能连上，但是不能上网，那8成是服务器没有做好 ip 转发或者 SNAT 的问题，还有可能是 DNS 的问题</p>

<h3>杂项</h3>

<p>最后说一下相关细节，没兴趣可以不看。网上其它有关使用 openswan 或者 strongSwan 配置 ipsec 的文章大都使用的 <a href="http://en.wikipedia.org/wiki/Internet_Key_Exchange">ikev1</a> 协议，但是 Nokia 的客户端恰好支持更先进的 <a href="http://en.wikipedia.org/wiki/Internet_Key_Exchange#Improvements_with_IKEv2">ikev2</a> 协议(不能不赞一下~)，具有更好的连接稳定性，更好的 NAT 穿透性。之前我配置 Nokia VPN 和 openswan 使用 ikev1 也成功了，但是因为该死的 E71 的 bug (也许吧，看<a href="http://wiki.paepstin.info/nokia:vpn#new_nat_traversal_preference">这里</a>)要给 openswan 打补丁才行，整个折腾过程更悲催。经 <a href="https://twitter.com/#!/tjmao">@tjmao</a> 提醒才想起对 ikev2 支持更好的 strongSwan，才有了本文。</p>

<p>另外，如果你通过本文，成功建立了 VPN 服务器。那么一个 bonus 就是，你同时支持了 windows 7 的 ikev2 客户端，只要给 win7 也颁发安装证书，然后可以了。而且从此远离<a href="http://support.microsoft.com/kb/926179">恶心</a>的 L2TP over ipsec。你可以看<a href="http://wiki.strongswan.org/projects/strongswan/wiki/Windows7">这里</a> 以及 <a href="http://blog.tjmao.net/2011/03/is-64-bit-so-hard-for-compatibility.html">这里</a></p>

<p>最后的最后，本文一部分是边实验边写的，还有一部分是凭记忆写的，所以如果有什么问题，欢迎在下面提出来，看看有什么错误或者漏掉的。</p>

<p>Good luck~</p>

<p>Posted via <a href="http://sinolog.it/?p=1894">UltraBlog.vim</a>.</p>
]]></content>
  </entry>
  
</feed>
